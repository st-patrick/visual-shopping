<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Visual Shopping — MVP</title>
<style>
  :root{
    --bg:#0f1116; --panel:#151922; --card:#1a1f2b; --fg:#e8ecf3; --muted:#97a1b3; --acc:#7bd88f;
    --border:#222835; --shadow:0 12px 40px rgba(0,0,0,.25);
    --gap:16px; --radius:16px; --radius-lg:22px;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0d0f14,#0b0e13);color:var(--fg);
       font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  a{color:inherit}

  .topbar{position:sticky;top:0;z-index:10;display:flex;gap:10px;align-items:center;
          padding:12px clamp(12px,4vw,28px);background:linear-gradient(180deg,rgba(10,12,18,.95),rgba(10,12,18,.55));
          border-bottom:1px solid var(--border);backdrop-filter:saturate(140%) blur(8px)}
  .brand{font-size:15px;font-weight:700;letter-spacing:.3px;display:flex;align-items:center;gap:10px}
  .brand .dot{width:10px;height:10px;border-radius:50%;background:var(--acc);box-shadow:0 0 0 6px rgba(123,216,143,.15)}
  .actions{display:flex;gap:10px;margin-left:auto}
  .ctrl{background:var(--panel);border:1px solid var(--border);color:var(--fg);border-radius:12px;padding:8px 12px;cursor:pointer}
  .ctrl:hover{border-color:#2b3344}
  .ctrl.primary{background:linear-gradient(180deg,#212835,#1a202c);border-color:#2a3342}
  .ctrl.danger{background:linear-gradient(180deg,#2a1c20,#23171a);border-color:#3a2630;color:#ffb3c0}
  .ctrl:disabled{opacity:.5;cursor:not-allowed}

  .searchbar{display:flex;align-items:center;gap:10px;background:var(--panel);border:1px solid var(--border);
             padding:8px 12px;border-radius:12px;min-width:220px}
  .searchbar input{all:unset;flex:1}

  .grid-wrap{padding:22px clamp(12px,4vw,28px)}
  .grid{column-gap:var(--gap)}
  /* Responsive column sizing: increases columns as width grows */
  @media (min-width:320px){ .grid{columns: 1} }
  @media (min-width:520px){ .grid{columns: 2} }
  @media (min-width:820px){ .grid{columns: 3} }
  @media (min-width:1100px){ .grid{columns: 4} }
  @media (min-width:1400px){ .grid{columns: 5} }

  .card{display:inline-block; width:100%; margin:0 0 var(--gap); background:var(--card);
  border:1px solid var(--border); border-radius:var(--radius); overflow:hidden; box-shadow:var(--shadow);
  break-inside:avoid; position:relative; cursor:grab}
  .card.no-drag{cursor:pointer}
  .card.dragging{opacity:.45; transform:scale(.98); cursor:grabbing}
  .card.drag-over-top::before, .card.drag-over-bottom::before{content:""; position:absolute; left:6px; right:6px; height:4px;
    border-radius:999px; background:var(--acc); box-shadow:0 0 8px rgba(123,216,143,.6)}
  .card.drag-over-top::before{top:6px}
  .card.drag-over-bottom::before{bottom:6px}
  .card img{width:100%; display:block; background:#0b0d12}
  .meta{padding:10px 12px; display:grid; gap:8px}
  .row{display:flex; align-items:center; justify-content:space-between; gap:8px}
  .title{font-weight:600; line-height:1.3}
  .price{font-weight:700}
  .src{color:var(--muted); font-size:12px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}

  .badge{font-size:11px; padding:5px 8px; border-radius:999px; border:1px solid var(--border); background:var(--panel)}
  .badge-archived{background:#221d1f; border-color:#3a2c30; color:#ffb3c0}
  .autoFill{display:flex; gap:8px}
  .autoFill input{flex:1}
  .image-options{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
  .image-option{border:1px solid var(--border); background:#0f141d; border-radius:12px; padding:4px; cursor:pointer; display:flex; flex-direction:column; align-items:center; gap:6px; min-width:86px}
  .image-option img{width:78px; height:78px; object-fit:cover; border-radius:8px; box-shadow:var(--shadow)}
  .image-option span{font-size:10px; color:var(--muted); text-align:center}
  .image-option.active{border-color:var(--acc); box-shadow:0 0 0 2px rgba(123,216,143,.35)}
  .scrape-status{font-size:12px; color:var(--muted); min-height:16px}
  .scrape-status.error{color:#ffb3c0}
  .scrape-status.success{color:var(--acc)}

  .overlay{position:absolute; inset:8px; display:flex; gap:8px; justify-content:flex-end; pointer-events:none}
  .overlay .iconbtn{pointer-events:auto; border:1px solid var(--border); background:rgba(11,14,20,.65); backdrop-filter: blur(6px) saturate(140%);
                    padding:6px 8px; border-radius:12px; cursor:pointer}

  .select-check{position:absolute; top:10px; left:10px; width:22px; height:22px}

  /* Dialog / Modal */
  dialog{border:none; padding:0; border-radius:var(--radius-lg); background:var(--panel); color:var(--fg);
         border:1px solid var(--border); box-shadow:var(--shadow); width:min(880px,94vw)}
  dialog::backdrop{background:rgba(0,0,0,.5)}
  .dlg-head{display:flex; align-items:center; justify-content:space-between; padding:14px 16px; border-bottom:1px solid var(--border)}
  .dlg-body{padding:16px; display:grid; gap:14px}
  .grid2{display:grid; grid-template-columns:1.2fr .8fr; gap:16px}
  .field{display:grid; gap:8px}
  .field label{font-size:12px; color:var(--muted)}
  .field input[type="text"], .field input[type="url"], .field input[type="number"], .field textarea{
     all:unset; background:#0f141d; border:1px solid var(--border); border-radius:12px; padding:10px 12px}
  .field textarea{min-height:72px}
  .dropzone{border:1px dashed #344054; border-radius:12px; padding:12px; display:grid; gap:8px; place-items:center; text-align:center; background:#101521}
  .dropzone.drag{border-color:var(--acc); box-shadow:0 0 0 3px rgba(123,216,143,.18) inset}
  .dlg-foot{display:flex; justify-content:space-between; padding:14px 16px; border-top:1px solid var(--border)}

  .hint{color:var(--muted); font-size:12px}
  .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px; background:#111827; border:1px solid var(--border); font-size:12px}
  .hidden{display:none}
  /* Preview image inside dropzone should never blow up the layout */
  .dropzone{border:1px dashed #344054; border-radius:12px; padding:12px; display:grid; gap:8px; place-items:center; text-align:center; background:#101521; min-height:220px}
  .dropzone img{max-width:100%; height:auto; max-height:180px; object-fit:contain; border-radius:10px; box-shadow:var(--shadow)}
  /* Developer controls placed in meta area (not overlaying the image) */
  .devbtn{border:1px solid var(--border); background:#0e1420; padding:4px 8px; border-radius:10px; cursor:pointer; font-size:12px}
  .devbtn:hover{border-color:#2b3344}
  /* Hover-only info overlay; default feed = images only */
  .hoverInfo{position:absolute; left:0; right:0; bottom:0; padding:10px 12px; pointer-events:none;
             background:linear-gradient(180deg, rgba(0,0,0,0), rgba(0,0,0,.65) 40%, rgba(0,0,0,.85));
             opacity:0; transform:translateY(6px); transition:opacity .2s ease, transform .2s ease}
  .card:hover .hoverInfo{opacity:1; transform:translateY(0)}
  .hoverRow{display:flex; align-items:center; justify-content:space-between; gap:8px}
  .hoverTitle{font-weight:700; text-shadow:0 1px 2px rgba(0,0,0,.6)}
  .hoverSrc{font-size:11px; color:var(--muted); opacity:.85; margin-top:4px}
  body[data-dev="off"] .meta{display:none}
</style>
</head>
<body>
  <div class="topbar">
    <div class="brand"><span class="dot"></span> Visual Shopping · MVP</div>
    <div class="searchbar" title="Search title/source/tags">
      <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
      <input id="q" placeholder="Search… (t/title, s/source, #tags)" />
    </div>
    <div class="actions">
  <button class="ctrl primary" id="addBtn" title="Add (+)">＋ Add</button>
      <button class="ctrl" id="exportBtn" title="Export JSON">Export</button>
      <button class="ctrl" id="zipBtn" title="Export ZIP (packs JSON + any embedded images)">ZIP</button>
      <button class="ctrl" id="folderBtn" title="Export to folder (File System Access API)">Folder</button>
      <button class="ctrl" id="importBtn" title="Import JSON">Import</button>
  <button class="ctrl" id="devToggle" title="Toggle developer controls (D)">Dev: Off</button>
  <button class="ctrl" id="archiveToggle" title="Show only archived items (A)">Archived: Off</button>
      <button class="ctrl" id="selectBtn" title="Toggle select mode (multi-delete)">Select</button>
      <button class="ctrl danger" id="delBtn" disabled>Delete</button>
    </div>
  </div>

  <div class="grid-wrap">
    <div id="grid" class="grid"></div>
  </div>

  <!-- Editor Dialog -->
  <dialog id="editor">
    <form method="dialog" id="editForm">
      <div class="dlg-head">
        <div style="font-weight:700">Add / Edit Product</div>
        <button class="ctrl" value="cancel" id="closeEdit">Close</button>
      </div>
      <div class="dlg-body">
        <div class="field">
          <label>Auto-fill from URL</label>
          <div class="autoFill">
            <input type="url" id="f_scrape" placeholder="Paste a product page URL" />
            <button class="ctrl" id="scrapeBtn" type="button">Fetch</button>
          </div>
          <div class="scrape-status" id="scrapeStatus"></div>
        </div>
        <div class="grid2">
          <div class="left">
          <div class="field"><label>Title</label><input type="text" id="f_title" required placeholder="e.g. Bodum French Press 1L" /></div>
          <div class="field"><label>Source Link</label><input type="url" id="f_link" placeholder="https://…" /></div>
          <div class="field"><label>Tags (comma‑separated)</label><input type="text" id="f_tags" placeholder="kitchen, minimal, glass" /></div>
          <div class="field"><label>Notes</label><textarea id="f_notes" placeholder="Anything relevant (finish, variant, etc.)"></textarea></div>
          </div>
          <div class="right">
          <div class="field"><label>Price</label>
            <div style="display:flex; gap:8px">
              <input type="number" id="f_price" min="0" step="0.01" placeholder="0.00" style="flex:1" />
              <input type="text" id="f_currency" value="EUR" style="width:80px" />
            </div>
          </div>
          <div class="field"><label>Image</label>
            <div class="dropzone" id="drop">
              <div>
                <div style="font-weight:600">Drop / Paste an image here</div>
                <div class="hint">or choose a file or paste an image URL below</div>
              </div>
              <input type="file" id="f_file" accept="image/*" />
              <img id="preview" alt="preview" class="hidden"/>
            </div>
            <div id="imageOptionsWrap" class="hidden"></div>
            <div class="field"><label>Image URL (optional)</label><input type="url" id="f_imgurl" placeholder="https://… (will be hot‑linked)" /></div>
            <div class="hint">Local images are compressed and embedded (saves with your data). Remote URLs are hot‑linked (lighter, but could break).</div>
          </div>
          </div>
        </div>
      </div>
      <div class="dlg-foot">
  <div class="hint">Tip: Press <b>+</b> to open this quickly. Clipboard images work.</div>
        <div style="display:flex; gap:8px">
          <button class="ctrl" id="dupBtn" type="button">Duplicate</button>
          <button class="ctrl primary" id="saveBtn" value="default">Save</button>
        </div>
      </div>
    </form>
  </dialog>

  <input type="file" id="importFile" accept="application/json" class="hidden" />

<script>
(() => {
  const STORE_KEY = 'vshop.v1';
  const grid = document.getElementById('grid');
  grid.addEventListener('dragover', handleGridDragOver);
  grid.addEventListener('drop', handleGridDrop);
  const q = document.getElementById('q');
  const addBtn = document.getElementById('addBtn');const delBtn = document.getElementById('delBtn');
  const devToggle = document.getElementById('devToggle');
  const archiveToggle = document.getElementById('archiveToggle');
  const folderBtn = document.getElementById('folderBtn');
  const importFile = document.getElementById('importFile');

  const editor = document.getElementById('editor');
  const f_title = document.getElementById('f_title');
  const f_link  = document.getElementById('f_link');
  const f_tags  = document.getElementById('f_tags');
  const f_notes = document.getElementById('f_notes');
  const f_price = document.getElementById('f_price');
  const f_curr  = document.getElementById('f_currency');
  const f_file  = document.getElementById('f_file');
  const f_imgurl= document.getElementById('f_imgurl');
  const drop    = document.getElementById('drop');
  const preview = document.getElementById('preview');
  const dupBtn  = document.getElementById('dupBtn');
  const scrapeInput = document.getElementById('f_scrape');
  const scrapeBtn = document.getElementById('scrapeBtn');
  const scrapeStatus = document.getElementById('scrapeStatus');
  const imageOptionsWrap = document.getElementById('imageOptionsWrap');

  let state = load();
  ensureSettingsDefaults();
  let selectMode = false;
  let selected = new Set();
  let currentEditId = null; // if null => add new
  let dragState = { id:null, hoverEl:null };
  let imageCandidates = [];
  let selectedImageCandidate = -1;

  function uid(){ return 'p' + Date.now().toString(36) + Math.random().toString(36).slice(2,7); }

  function load(){
    try{ const raw = localStorage.getItem(STORE_KEY); if(!raw) return {products:[], settings:{}}; return JSON.parse(raw); }
    catch(e){ console.warn('Failed to load, starting fresh', e); return {products:[], settings:{}}; }
  }
  function save(){ try{ localStorage.setItem(STORE_KEY, JSON.stringify(state)); }catch(e){ alert('Save failed (maybe localStorage full). Consider exporting & clearing.'); console.error(e);} }

  function domainOf(url){ try { return new URL(url).hostname.replace('www.',''); } catch { return ''; } }
  function fmtPrice(p){ if(p==null || p=== '') return ''; const num = Number(p); if(Number.isFinite(num)) return num.toFixed(2); return p; }
  function ensureSettingsDefaults(){
    state.settings = state.settings || {};
    if(typeof state.settings.devMode !== 'boolean'){ state.settings.devMode = false; }
    if(typeof state.settings.showArchivedOnly !== 'boolean'){ state.settings.showArchivedOnly = false; }
    if(!Array.isArray(state.settings.order)){ state.settings.order = []; }
    reconcileOrder();
  }
  function reconcileOrder(){
    if(!state || !Array.isArray(state.products)){ return; }
    for(const p of state.products){
      if(!p.id){ p.id = uid(); }
      if(typeof p.archived !== 'boolean'){ p.archived = false; }
    }
    const ids = state.products.map(p=>p.id).filter(Boolean);
    const seen = new Set();
    const existing = Array.isArray(state.settings.order)
      ? state.settings.order.filter(id=>{
          if(!ids.includes(id) || seen.has(id)){ return false; }
          seen.add(id);
          return true;
        })
      : [];
    const missing = state.products
      .filter(p=>!seen.has(p.id))
      .sort((a,b)=> (b.createdAt||0) - (a.createdAt||0))
      .map(p=>p.id);
    state.settings.order = [...missing, ...existing];
    syncProductsToOrder();
  }
  function syncProductsToOrder(){
    if(!Array.isArray(state.products) || !Array.isArray(state.settings.order)){ return; }
    const orderIndex = new Map(state.settings.order.map((id, idx)=>[id, idx]));
    state.products.sort((a,b)=>{
      const ai = orderIndex.has(a.id) ? orderIndex.get(a.id) : Number.MAX_SAFE_INTEGER;
      const bi = orderIndex.has(b.id) ? orderIndex.get(b.id) : Number.MAX_SAFE_INTEGER;
      return ai - bi;
    });
  }

  function render(){
    updateDevToggleLabel();
    updateArchiveToggleLabel();
    dragState.hoverEl = null;
    dragState.id = null;
    const term = (q.value||'').trim().toLowerCase();
    grid.innerHTML = '';
    const order = Array.isArray(state.settings.order) ? state.settings.order : [];
    const orderIndex = new Map(order.map((id, idx)=>[id, idx]));
    const items = state.products.slice().sort((a,b)=>{
      const ai = orderIndex.has(a.id) ? orderIndex.get(a.id) : Number.MAX_SAFE_INTEGER;
      const bi = orderIndex.has(b.id) ? orderIndex.get(b.id) : Number.MAX_SAFE_INTEGER;
      if(ai !== bi){ return ai - bi; }
      return (b.createdAt||0) - (a.createdAt||0);
    });
    const dragEnabled = !selectMode && term === '';
    const showArchivedOnly = Boolean(state.settings.showArchivedOnly);
    for(const it of items){
      if(showArchivedOnly){
        if(!it.archived){ continue; }
      } else if(it.archived){
        continue;
      }
      if(term){
        const hay = [it.title, it.link, (it.tags||[]).join(','), it.notes||''].join(' ').toLowerCase();
        if(!hay.includes(term) && !(term.startsWith('t:') && (it.title||'').toLowerCase().includes(term.slice(2).trim()))
           && !(term.startsWith('s:') && (it.link||'').toLowerCase().includes(term.slice(2).trim()))
           && !(term.startsWith('#') && (it.tags||[]).some(t=>t.toLowerCase().includes(term.slice(1))))) continue;
      }
      const el = document.createElement('article');
      el.className = 'card';
      el.dataset.id = it.id;
  if(it.archived){ el.classList.add('archived'); }
      const imgSrc = it.image?.dataURL || it.image?.url || '';
      const img = `<img loading="lazy" alt="${escapeHtml(it.title||'product')}" src="${escapeAttr(imgSrc)}">`;
      const src = it.link ? `<a href="${escapeAttr(it.link)}" target="_blank" rel="noopener noreferrer" class="src">${escapeHtml(domainOf(it.link))}</a>` : '<span class="src">—</span>';
      const price = it.price?.amount? `<span class="price">${escapeHtml(fmtPrice(it.price.amount))} ${escapeHtml(it.price.currency||'')}</span>` : '<span class="price"></span>';
      const tagsRaw = (it.tags||[]).slice(0,4).map(t=>`<span class="badge">#${escapeHtml(t)}</span>`).join(' ');
      const archivedBadge = it.archived ? '<span class="badge badge-archived">Archived</span>' : '';
      const tags = [archivedBadge, tagsRaw].filter(Boolean).join(' ');
      const archiveLabel = it.archived ? 'Unarchive' : 'Archive';
      const archiveTitle = it.archived ? 'Move back to active list' : 'Move to archive';
      el.innerHTML = `
        ${img}
        ${selectMode? `<input class=\"select-check\" type=\"checkbox\" ${selected.has(it.id)?'checked':''}/>`:''}
        <div class=\"hoverInfo\">
          <div class=\"hoverRow\">
            <div class=\"hoverTitle\">${escapeHtml(it.title||'Untitled')}</div>
            ${price}
          </div>
          <div class=\"hoverSrc\">${escapeHtml(domainOf(it.link))}</div>
        </div>
        <div class=\"meta\">
          <div class=\"row\">
            <div class=\"title\">${escapeHtml(it.title||'Untitled')}</div>
            <div style=\"display:flex;align-items:center;gap:8px\">
              ${price}
              ${state.settings?.devMode ? `<button class=\"devbtn\" data-act=\"edit\" title=\"Edit\">✎</button><button class=\"devbtn\" data-act=\"copy\" title=\"Copy JSON\">⧉</button><button class=\"devbtn\" data-act=\"archive\" title=\"${escapeAttr(archiveTitle)}\">${archiveLabel}</button>` : ''}
            </div>
          </div>
          <div class=\"row\">
            ${src}
            <div>${tags}</div>
          </div>
        </div>`;
      el.addEventListener('click', (e)=>{
        const act = e.target?.dataset?.act;
        if(act==='edit'){ openEditor(it.id); e.stopPropagation(); return; }
        if(act==='copy'){ navigator.clipboard.writeText(JSON.stringify(it,null,2)); e.stopPropagation(); return; }
        if(act==='archive'){ toggleArchive(it.id); e.stopPropagation(); return; }
        if(selectMode){
          const chk = el.querySelector('.select-check');
          chk.checked = !chk.checked;
          chk.dispatchEvent(new Event('change'));
        } else if(it.link){ window.open(it.link, '_blank','noopener'); }
      });
      if(selectMode){
        const chk = el.querySelector('.select-check');
        chk.addEventListener('change', ()=>{ chk.checked? selected.add(it.id): selected.delete(it.id); updateDeleteButton(); });
        el.draggable = false;
        el.classList.add('no-drag');
      } else if(dragEnabled){
        enableCardDrag(el);
      } else {
        el.draggable = false;
        el.classList.add('no-drag');
      }
      grid.appendChild(el);
    }
  }

  function updateDeleteButton(){ delBtn.disabled = selected.size===0; }

  function toggleArchive(id){
    const product = state.products.find(p=>p.id===id);
    if(!product){ return; }
    product.archived = !product.archived;
    save();
    render();
  }

  function setScrapeStatus(message, tone){
    if(!scrapeStatus){ return; }
    scrapeStatus.textContent = message || '';
    scrapeStatus.classList.remove('error','success');
    if(tone){ scrapeStatus.classList.add(tone); }
  }

  function resetImagePicker(){
    imageCandidates = [];
    selectedImageCandidate = -1;
    if(imageOptionsWrap){
      imageOptionsWrap.innerHTML = '';
      imageOptionsWrap.classList.add('hidden');
    }
  }

  function updateImageOptionSelection(){
    if(!imageOptionsWrap){ return; }
    const options = imageOptionsWrap.querySelectorAll('.image-option');
    options.forEach(opt=>{
      const idx = Number(opt.dataset.index);
      opt.classList.toggle('active', idx === selectedImageCandidate);
    });
  }

  function renderImageOptions(){
    if(!imageOptionsWrap){ return; }
    imageOptionsWrap.innerHTML = '';
    if(!imageCandidates.length){
      imageOptionsWrap.classList.add('hidden');
      return;
    }
    imageOptionsWrap.classList.remove('hidden');
    const label = document.createElement('div');
    label.className = 'hint';
    label.textContent = 'Choose an image to use:';
    imageOptionsWrap.appendChild(label);
    const list = document.createElement('div');
    list.className = 'image-options';
    imageCandidates.forEach((src, idx)=>{
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'image-option';
      btn.dataset.index = String(idx);
      btn.innerHTML = `<img src="${escapeAttr(src)}" alt="Candidate ${idx+1}"><span>Option ${idx+1}</span>`;
      btn.addEventListener('click', ()=>selectImageCandidate(idx));
      list.appendChild(btn);
    });
    imageOptionsWrap.appendChild(list);
    updateImageOptionSelection();
  }

  function selectImageCandidate(idx){
    if(idx < 0 || idx >= imageCandidates.length){ return; }
    const src = imageCandidates[idx];
    selectedImageCandidate = idx;
    if(preview){
      preview.src = src;
      preview.classList.remove('hidden');
    }
    if(f_imgurl){ f_imgurl.value = src; }
    if(f_file){ f_file.value = ''; }
    updateImageOptionSelection();
  }

  async function autoFillFromUrl(rawUrl){
    const url = (rawUrl || '').trim();
    if(!url){
      setScrapeStatus('Enter a valid URL first.', 'error');
      return;
    }
    const normalized = /^https?:\/\//i.test(url) ? url : `https://${url}`;
    setScrapeStatus('Fetching…');
    const prevLabel = scrapeBtn?.textContent;
    if(scrapeBtn){ scrapeBtn.disabled = true; scrapeBtn.textContent = 'Fetching…'; }
    try{
      const html = await fetchProductHTML(normalized);
      if(!html){ throw new Error('Empty response'); }
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
      const baseHref = doc.querySelector('base[href]')?.getAttribute('href') || '';
      const baseUrl = resolveMaybe(baseHref, normalized) || normalized;
      const info = extractProductInfo(doc, baseUrl, normalized);
      applyScrapeResult(info, normalized);
      setScrapeStatus('Auto-filled from page.', 'success');
    }catch(err){
      console.error('Auto-fill failed', err);
      setScrapeStatus(`Auto-fill failed: ${err.message || err}`, 'error');
    }finally{
      if(scrapeBtn){
        scrapeBtn.disabled = false;
        scrapeBtn.textContent = prevLabel || 'Fetch';
      }
    }
  }

  async function fetchProductHTML(url){
    let lastError = null;
    try{
      const direct = await fetch(url, { mode:'cors' });
      if(direct.ok){
        const text = await direct.text();
        if(text){ return text; }
      }
    }catch(err){
      lastError = err;
    }
    try{
      const proxyUrl = buildProxyUrl(url);
      const proxied = await fetch(proxyUrl, { mode:'cors' });
      if(!proxied.ok){ throw new Error(`Proxy fetch failed (${proxied.status})`); }
      return await proxied.text();
    }catch(err){
      throw err || lastError || new Error('Fetch failed');
    }
  }

  function buildProxyUrl(url){
    const parsed = new URL(url);
    return `https://r.jina.ai/${parsed.protocol}//${parsed.host}${parsed.pathname}${parsed.search}${parsed.hash}`;
  }

  function applyScrapeResult(info, fallbackUrl){
    if(!info || typeof info !== 'object'){ throw new Error('No data returned'); }
    const resolvedUrl = info.url || fallbackUrl;
    if(f_link && resolvedUrl){ f_link.value = resolvedUrl; }
    if(scrapeInput && resolvedUrl){ scrapeInput.value = resolvedUrl; }
    if(info.title && !f_title.value){ f_title.value = info.title; }
    if(info.description && !f_notes.value){ f_notes.value = info.description; }
    if(info.tags && info.tags.length && !f_tags.value){ f_tags.value = info.tags.join(', '); }
    if(info.price && !f_price.value){ f_price.value = info.price; }
    if(info.currency){ f_curr.value = info.currency; }
    resetImagePicker();
    if(info.images && info.images.length){
      imageCandidates = info.images;
      selectedImageCandidate = -1;
      renderImageOptions();
      if(!preview.src || preview.classList.contains('hidden')){
        selectImageCandidate(0);
      } else {
        updateImageOptionSelection();
      }
    }
  }

  function extractProductInfo(doc, baseUrl, originalUrl){
    const meta = sel => (doc.querySelector(sel)?.getAttribute('content') || '').trim();
    const textContent = sel => (doc.querySelector(sel)?.textContent || '').trim();
    const canonicalHref = doc.querySelector('link[rel="canonical"]')?.getAttribute('href');
    const ogUrl = meta('meta[property="og:url"]');
    const info = {
      url: resolveMaybe(canonicalHref, originalUrl) || resolveMaybe(ogUrl, originalUrl) || originalUrl,
      title: '',
      description: '',
      price: '',
      currency: '',
      tags: [],
      images: []
    };
    const titleCandidates = [
      meta('meta[property="og:title"]'),
      meta('meta[name="twitter:title"]'),
      textContent('title')
    ].filter(Boolean);
    info.title = titleCandidates[0] || '';

    const descCandidates = [
      meta('meta[name="description"]'),
      meta('meta[property="og:description"]'),
      meta('meta[name="twitter:description"]')
    ].filter(Boolean);
    info.description = descCandidates[0] || '';

    const priceCandidates = [
      meta('meta[property="product:price:amount"]'),
      meta('meta[name="twitter:data1"]'),
      doc.querySelector('[itemprop="price"]')?.getAttribute('content') || doc.querySelector('[itemprop="price"]')?.textContent?.trim()
    ].filter(Boolean);
    info.price = normalizePrice(priceCandidates[0] || '');

    const currencyCandidates = [
      meta('meta[property="product:price:currency"]'),
      doc.querySelector('[itemprop="priceCurrency"]')?.getAttribute('content')
    ].filter(Boolean);
    const currencyRaw = currencyCandidates[0] || '';
    info.currency = currencyRaw ? currencyRaw.toUpperCase().slice(0,3) : '';

    const keywords = meta('meta[name="keywords"]');
    if(keywords){
      info.tags = keywords.split(',').map(t=>t.trim()).filter(Boolean).slice(0,6);
    }

    const addImage = (src)=>{
      const resolved = resolveMaybe(src, baseUrl || originalUrl);
      if(resolved && !info.images.includes(resolved)){ info.images.push(resolved); }
    };
    [
      meta('meta[property="og:image"]'),
      meta('meta[property="og:image:secure_url"]'),
      meta('meta[name="twitter:image"]'),
      doc.querySelector('link[rel="image_src"]')?.getAttribute('href')
    ].filter(Boolean).forEach(addImage);

    const ldProduct = extractProductFromJSONLD(doc);
    if(ldProduct){
      info.title = info.title || ldProduct.name || '';
      info.description = info.description || ldProduct.description || '';
      if(ldProduct.category && !info.tags.length){
        const categories = Array.isArray(ldProduct.category) ? ldProduct.category : [ldProduct.category];
        info.tags = categories.map(String).map(t=>t.trim()).filter(Boolean).slice(0,6);
      }
      if(ldProduct.keywords && !info.tags.length){
        const kw = Array.isArray(ldProduct.keywords) ? ldProduct.keywords : String(ldProduct.keywords).split(',');
        info.tags = kw.map(String).map(t=>t.trim()).filter(Boolean).slice(0,6);
      }
      const offers = Array.isArray(ldProduct.offers) ? ldProduct.offers[0] : ldProduct.offers;
      if(offers){
        info.price = info.price || normalizePrice(offers.price || offers.priceSpecification?.price || '');
        const currency = offers.priceCurrency || offers.priceSpecification?.priceCurrency;
        if(currency){ info.currency = currency.toUpperCase().slice(0,3); }
      }
      const ldImages = Array.isArray(ldProduct.image) ? ldProduct.image : [ldProduct.image];
      ldImages.filter(Boolean).forEach(addImage);
      if(ldProduct.url){ info.url = resolveMaybe(ldProduct.url, baseUrl) || info.url; }
    }

    info.images = info.images.filter(Boolean);
    if(info.currency && info.currency.length !==3){ info.currency = ''; }
    return info;
  }

  function extractProductFromJSONLD(doc){
    const scripts = [...doc.querySelectorAll('script[type="application/ld+json"]')];
    for(const script of scripts){
      const text = script.textContent?.trim();
      if(!text){ continue; }
      try{
        const json = JSON.parse(text);
        const product = findProductNode(json);
        if(product){ return product; }
      }catch(err){
        continue;
      }
    }
    return null;
  }

  function findProductNode(node){
    if(!node){ return null; }
    if(Array.isArray(node)){
      for(const item of node){
        const found = findProductNode(item);
        if(found){ return found; }
      }
      return null;
    }
    if(typeof node === 'object'){
      const type = node['@type'];
      const isProduct = Array.isArray(type) ? type.includes('Product') : type === 'Product';
      if(isProduct){ return node; }
      for(const key of Object.keys(node)){
        const found = findProductNode(node[key]);
        if(found){ return found; }
      }
    }
    return null;
  }

  function resolveMaybe(url, base){
    if(!url){ return ''; }
    try{ return new URL(url, base).href; }catch{ return ''; }
  }

  function normalizePrice(value){
    if(!value){ return ''; }
    const cleaned = String(value).trim();
    if(!cleaned){ return ''; }
    const replaced = cleaned.replace(/[^0-9.,]/g, '');
    if(!replaced){ return ''; }
    if(replaced.includes(',') && !replaced.includes('.')){
      const lastComma = replaced.lastIndexOf(',');
      return replaced.slice(0,lastComma).replace(/,/g,'') + '.' + replaced.slice(lastComma+1);
    }
    return replaced;
  }

  function enableCardDrag(el){
    el.classList.remove('no-drag','dragging','drag-over-top','drag-over-bottom');
    el.draggable = true;
    el.addEventListener('dragstart', handleCardDragStart);
    el.addEventListener('dragend', handleCardDragEnd);
    el.addEventListener('dragover', handleCardDragOver);
    el.addEventListener('dragleave', handleCardDragLeave);
    el.addEventListener('drop', handleCardDrop);
  }
  function handleCardDragStart(e){
    if(selectMode){ e.preventDefault(); return; }
    const card = e.currentTarget;
    if(e.target && (e.target.closest('.devbtn') || e.target.closest('.select-check') || e.target.closest('.iconbtn'))){
      e.preventDefault();
      return;
    }
    dragState.id = card.dataset.id;
    if(!dragState.id){ e.preventDefault(); dragState.id = null; return; }
    dragState.hoverEl = null;
    e.dataTransfer.effectAllowed = 'move';
    try{ e.dataTransfer.setData('text/plain', dragState.id || ''); }catch{}
    card.classList.add('dragging');
  }
  function handleCardDragEnd(e){
    const card = e.currentTarget;
    card.classList.remove('dragging');
    clearDragHover();
    dragState.id = null;
  }
  function handleCardDragOver(e){
    if(!dragState.id || selectMode){ return; }
    const card = e.currentTarget;
    if(card.dataset.id === dragState.id){ return; }
    e.preventDefault();
    const rect = card.getBoundingClientRect();
    const before = e.clientY < rect.top + rect.height / 2;
    if(dragState.hoverEl && dragState.hoverEl !== card){
      dragState.hoverEl.classList.remove('drag-over-top','drag-over-bottom');
    }
    card.classList.toggle('drag-over-top', before);
    card.classList.toggle('drag-over-bottom', !before);
    dragState.hoverEl = card;
  }
  function handleCardDragLeave(e){
    const card = e.currentTarget;
    if(card === dragState.hoverEl){
      card.classList.remove('drag-over-top','drag-over-bottom');
      dragState.hoverEl = null;
    }
  }
  function handleCardDrop(e){
    if(!dragState.id || selectMode){ return; }
    e.preventDefault();
    e.stopPropagation();
    const target = e.currentTarget;
    const targetId = target.dataset.id;
    const rect = target.getBoundingClientRect();
    const before = e.clientY < rect.top + rect.height / 2;
    target.classList.remove('drag-over-top','drag-over-bottom');
    clearDragHover();
    if(targetId && targetId !== dragState.id){
      reorderProducts(dragState.id, targetId, before);
    } else {
      dragState.id = null;
    }
  }
  function handleGridDragOver(e){
    if(!dragState.id || selectMode){ return; }
    e.preventDefault();
  }
  function handleGridDrop(e){
    if(!dragState.id || selectMode){ return; }
    e.preventDefault();
    clearDragHover();
    reorderProducts(dragState.id, null, false);
  }
  function clearDragHover(){
    if(dragState.hoverEl){
      dragState.hoverEl.classList.remove('drag-over-top','drag-over-bottom');
      dragState.hoverEl = null;
    }
  }
  function reorderProducts(sourceId, targetId, placeBefore){
    const order = Array.isArray(state.settings.order) ? [...state.settings.order] : [];
    const srcIdx = order.indexOf(sourceId);
    if(srcIdx === -1){ return; }
    order.splice(srcIdx, 1);
    if(targetId){
      let insertAt = order.indexOf(targetId);
      if(insertAt === -1){ insertAt = placeBefore ? order.length : order.length; }
      if(!placeBefore){ insertAt += 1; }
      order.splice(insertAt, 0, sourceId);
    } else {
      if(placeBefore){ order.unshift(sourceId); }
      else { order.push(sourceId); }
    }
    state.settings.order = order;
    dragState.id = null;
    dragState.hoverEl = null;
    syncProductsToOrder();
    save();
    render();
  }

  function openEditor(id){
    currentEditId = id || null;
    const it = id ? state.products.find(p=>p.id===id) : { id: uid(), title:'', link:'', tags:[], notes:'', image:{}, price:{amount:'',currency:'EUR'}, createdAt:Date.now(), archived:false };
    if(scrapeInput){ scrapeInput.value = it?.link || ''; }
    setScrapeStatus('');
    resetImagePicker();
    f_title.value = it.title || '';
    f_link.value  = it.link || '';
    f_tags.value  = (it.tags||[]).join(', ');
    f_notes.value = it.notes || '';
    f_price.value = (it.price?.amount??'');
    f_curr.value  = it.price?.currency || 'EUR';
    f_imgurl.value= it.image?.url || '';
    preview.src = it.image?.dataURL || it.image?.url || '';
    preview.classList.toggle('hidden', !preview.src);
    dupBtn.onclick = () => { currentEditId = null; }; // saving will create a new id
    if(!editor.open) editor.showModal();
  }

  function closeEditor(){ if(editor.open) editor.close(); currentEditId = null; clearFileInputs(); }
  function clearFileInputs(){ f_file.value=''; drop.classList.remove('drag'); }

  async function readImageFromFile(file){
    // compress using canvas to keep storage small
    const maxW = 1280; const quality = 0.85;
    const dataUrl = await new Promise((resolve,reject)=>{ const r=new FileReader(); r.onload=()=>resolve(r.result); r.onerror=reject; r.readAsDataURL(file); });
    const img = await loadImage(dataUrl);
    const scale = Math.min(1, maxW/img.width);
    if(scale < 1){
      const w = Math.round(img.width*scale), h = Math.round(img.height*scale);
      const canvas = Object.assign(document.createElement('canvas'),{width:w,height:h});
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img,0,0,w,h);
      return canvas.toDataURL('image/jpeg', quality);
    } else {
      return dataUrl;
    }
  }
  function loadImage(src){ return new Promise((resolve,reject)=>{ const i=new Image(); i.onload=()=>resolve(i); i.onerror=reject; i.src=src; }); }

  // Event wiring
  addBtn.onclick = () => openEditor(null);
  if(scrapeBtn){ scrapeBtn.addEventListener('click', ()=>{ autoFillFromUrl(scrapeInput?.value || f_link.value); }); }
  if(scrapeInput){
    scrapeInput.addEventListener('keydown', e=>{
      if(e.key === 'Enter'){
        e.preventDefault();
        autoFillFromUrl(scrapeInput.value);
      }
    });
    scrapeInput.addEventListener('paste', e=>{
      requestAnimationFrame(()=>{ autoFillFromUrl(scrapeInput.value); });
    });
  }
  function hotkeysAllowed(target){
    if(!target){ return true; }
    if(target.isContentEditable){ return false; }
    const tag = target.tagName;
    return !(tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT');
  }

  document.addEventListener('keydown', e=>{
    if(!hotkeysAllowed(e.target)){ return; }
    const key = e.key?.toLowerCase();
    if(!key){ return; }
    if(key === '+' && !editor.open){
      e.preventDefault();
      openEditor(null);
      return;
    }
    if(key === 'd'){
      if(devToggle){ e.preventDefault(); devToggle.click(); }
      return;
    }
    if(key === 'a'){
      if(archiveToggle){ e.preventDefault(); archiveToggle.click(); }
      return;
    }
  });

  exportBtn.onclick = () => {
    const blob = new Blob([JSON.stringify(state,null,2)], {type:'application/json'});
    downloadBlob(blob, filename('visual-shop', 'json'));
  };

  importBtn.onclick = () => { importFile.click(); };
  importFile.onchange = async (e)=>{
    const file = e.target.files?.[0]; if(!file) return;
    try{
      const text = await file.text();
      const incoming = JSON.parse(text);
      if(!incoming || !Array.isArray(incoming.products)) throw new Error('Invalid JSON shape');
      const replace = confirm('Replace existing items? Cancel = Append');
      if(replace){
        state = { products: incoming.products || [], settings: incoming.settings || {} };
      } else {
        const newProducts = incoming.products || [];
        state.products.push(...newProducts);
        const incomingOrder = Array.isArray(incoming.settings?.order)
          ? incoming.settings.order.filter(Boolean)
          : newProducts.map(p=>p.id).filter(Boolean);
        if(!Array.isArray(state.settings.order)){ state.settings.order = []; }
        state.settings.order = [...incomingOrder, ...state.settings.order];
      }
      ensureSettingsDefaults();
      save(); render();
    }catch(err){ alert('Import failed: '+err.message); }
    finally{ importFile.value=''; }
  };

  zipBtn.onclick = async () => {
    try{
      if(!window.JSZip){ await loadJSZip(); }
      const zip = new JSZip();const imagesFolder = zip.folder('images');
      zip.file('README.txt', `This archive was created by Visual Shopping (local-only MVP).

If Windows shows a security prompt when opening files directly inside the ZIP, it's because the archive came from the Internet zone. Click 'Extract All…' first, then open files from the extracted folder.`);
      const copy = JSON.parse(JSON.stringify(state));
      // Extract embedded data URLs into /images and rewrite refs
      let imgIdx = 1;
      for(const p of copy.products){
        if(p.image && p.image.dataURL && p.image.dataURL.startsWith('data:')){
          const ext = p.image.dataURL.slice(5, p.image.dataURL.indexOf(';')) === 'image/png' ? 'png' : 'jpg';
          const name = `${p.id || 'img'}_${imgIdx++}.${ext}`;
          const base64 = p.image.dataURL.split(',')[1];
          imagesFolder.file(name, base64, {base64:true});
          p.image.file = `images/${name}`;
          // keep dataURL too for convenience
        }
      }
      zip.file('products.json', JSON.stringify(copy,null,2));
      const blob = await zip.generateAsync({type:'blob', compression:'DEFLATE', compressionOptions:{level:6}});
      downloadBlob(blob, filename('visual-shop', 'zip'));
    }catch(err){ alert('ZIP export failed (maybe offline?): '+err.message); }
  };

  selectBtn.onclick = () => { selectMode = !selectMode; selected.clear(); updateDeleteButton(); render(); };
  delBtn.onclick = () => {
    if(selected.size===0) return; if(!confirm(`Delete ${selected.size} item(s)?`)) return;
    state.products = state.products.filter(p => !selected.has(p.id));
    if(Array.isArray(state.settings.order)){
      state.settings.order = state.settings.order.filter(id => !selected.has(id));
    }
    selected.clear();
    reconcileOrder();
    save(); render(); updateDeleteButton();
  };

  q.addEventListener('input', ()=>render());

  function updateDevToggleLabel(){
    if(devToggle) devToggle.textContent = 'Dev: ' + (state.settings.devMode? 'On':'Off');
    document.body.dataset.dev = state.settings.devMode ? 'on' : 'off';
  }
  function updateArchiveToggleLabel(){
    if(archiveToggle) archiveToggle.textContent = state.settings.showArchivedOnly ? 'Archived: On' : 'Archived: Off';
  }
  if(archiveToggle){ archiveToggle.addEventListener('click', ()=>{ state.settings.showArchivedOnly = !state.settings.showArchivedOnly; updateArchiveToggleLabel(); save(); render(); }); }
  if(devToggle){ devToggle.addEventListener('click', ()=>{ state.settings.devMode = !state.settings.devMode; updateDevToggleLabel(); save(); render(); }); }
  // Ensure clicking the checkbox itself does not bubble to the card click
  document.addEventListener('click', (e)=>{ if(e.target && e.target.classList && e.target.classList.contains('select-check')) { e.stopPropagation(); } }, true);

  // Export to a real folder using the File System Access API (Chrome/Edge)
  async function exportToFolder(){
    if(!window.showDirectoryPicker){ alert('Your browser does not support Folder export. Use Chrome or Edge.'); return; }
    try{
      const dir = await window.showDirectoryPicker({ mode:'readwrite' });
      // Write JSON
      const jsonHandle = await dir.getFileHandle('products.json', { create:true });
      const jsonWritable = await jsonHandle.createWritable();
      await jsonWritable.write(JSON.stringify(state, null, 2));
      await jsonWritable.close();
      // Write images folder
      const imgDir = await dir.getDirectoryHandle('images', { create:true });
      let imgIdx = 1;
      for(const p of state.products){
        if(p.image && p.image.dataURL && p.image.dataURL.startsWith('data:')){
          const ext = p.image.dataURL.includes('image/png') ? 'png' : 'jpg';
          const name = `${p.id || 'img'}_${imgIdx++}.${ext}`;
          const fileHandle = await imgDir.getFileHandle(name, { create:true });
          const writable = await fileHandle.createWritable();
          await writable.write(dataUrlToBlob(p.image.dataURL));
          await writable.close();
        }
      }
      alert('Exported to selected folder. If Windows complained about ZIPs before, this route avoids that.');
    }catch(err){ if(err && err.name!=='AbortError') alert('Folder export failed: ' + err.message); }
  }
  if(folderBtn){ folderBtn.addEventListener('click', exportToFolder); }

  function dataUrlToBlob(dataURL){
    const [head, b64] = dataURL.split(',');
    const mimeMatch = head.match(/data:(.*?);base64/);
    const mime = mimeMatch ? mimeMatch[1] : 'application/octet-stream';
    const bin = atob(b64);
    const len = bin.length;
    const arr = new Uint8Array(len);
    for(let i=0;i<len;i++){ arr[i] = bin.charCodeAt(i); }
    return new Blob([arr], { type: mime });
  }

  // Editor interactions
  drop.addEventListener('dragover', e=>{ e.preventDefault(); drop.classList.add('drag'); });
  drop.addEventListener('dragleave', ()=>drop.classList.remove('drag'));
  drop.addEventListener('drop', async (e)=>{
    e.preventDefault(); drop.classList.remove('drag');
    const f = e.dataTransfer.files?.[0]; if(f) {
      const url = await readImageFromFile(f);
      preview.src=url;
      preview.classList.remove('hidden');
      f_imgurl.value='';
      selectedImageCandidate = -1;
      updateImageOptionSelection();
    }
  });
  drop.addEventListener('paste', async (e)=>{
    const item = [...(e.clipboardData?.items||[])].find(it=>it.type.startsWith('image/'));
    if(item){
      const file = item.getAsFile();
      const url = await readImageFromFile(file);
      preview.src=url;
      preview.classList.remove('hidden');
      f_imgurl.value='';
      selectedImageCandidate = -1;
      updateImageOptionSelection();
    }
  });
  f_file.addEventListener('change', async (e)=>{
    const f = e.target.files?.[0]; if(f){
      const url = await readImageFromFile(f);
      preview.src=url;
      preview.classList.remove('hidden');
      f_imgurl.value='';
      selectedImageCandidate = -1;
      updateImageOptionSelection();
    }
  });
  f_imgurl.addEventListener('input', ()=>{
    const val = f_imgurl.value.trim();
    if(val){
      preview.src = val;
      preview.classList.remove('hidden');
      f_file.value='';
      selectedImageCandidate = -1;
      updateImageOptionSelection();
    } else if(!f_file.files?.length && (!preview.src || !preview.src.startsWith('data:'))){
      preview.src='';
      preview.classList.add('hidden');
    }
  });

  editor.addEventListener('close', ()=>{ clearFileInputs(); });

  document.getElementById('saveBtn').addEventListener('click', (e)=>{
    e.preventDefault();
    const existing = currentEditId ? state.products.find(p=>p.id===currentEditId) : null;
    const base = {
      id: currentEditId || uid(),
      title: f_title.value.trim(),
      link: f_link.value.trim(),
      tags: f_tags.value.split(',').map(t=>t.trim()).filter(Boolean),
      notes: f_notes.value.trim(),
      image: {},
      price: { amount: f_price.value, currency: (f_curr.value||'').toUpperCase() },
      archived: existing?.archived ?? false,
      createdAt: existing?.createdAt || Date.now()
    };
  const imageUrl = f_imgurl.value.trim();
  if(preview.src && preview.src.startsWith('data:')){ base.image.dataURL = preview.src; }
  if(imageUrl){ base.image.url = imageUrl; }

    if(currentEditId){
      const idx = state.products.findIndex(p=>p.id===currentEditId);
      if(idx>=0) state.products[idx] = base; else state.products.push(base);
    } else {
      state.products.push(base);
    }
    reconcileOrder();
    save(); render(); closeEditor();
  });

  dupBtn.addEventListener('click', (e)=>{
    e.preventDefault(); currentEditId = null; const t = document.getElementById('saveBtn'); t.focus();
  });

  document.getElementById('closeEdit').addEventListener('click', (e)=>{ e.preventDefault(); closeEditor(); });

  function downloadBlob(blob, name){
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = name;
    document.body.appendChild(a);
    a.click();
    // Give the browser ample time to consume the blob before revoking
    setTimeout(()=>{ URL.revokeObjectURL(a.href); a.remove(); }, 60000);
  }
  function filename(base, ext){ const d=new Date(); const pad=n=>String(n).padStart(2,'0'); const ts=`${d.getFullYear()}${pad(d.getMonth()+1)}${pad(d.getDate())}-${pad(d.getHours())}${pad(d.getMinutes())}`; return `${base}-${ts}.${ext}`; }

  function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }
  function escapeAttr(s){ return (s||'').replace(/["\n\r]/g, c=>({"\"":"&quot;","\n":" ","\r":" "}[c])); }

  async function loadJSZip(){
    await new Promise((resolve,reject)=>{
      const s=document.createElement('script');
      s.src='https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
      s.crossOrigin='anonymous'; s.onload=resolve; s.onerror=()=>reject(new Error('CDN failed'));
      document.head.appendChild(s);
    });
  }

  // Boot
  render();
})();
</script>
</body>
</html>
